<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>API Circle - Multi-Ring Traffic & Latency</title>
    <style>
        :root {
            --bg: #0b1220;
            --fg: #e5e7eb;
            --muted: #94a3b8;
            --panel: #111826cc;
            --ring: #3b4456;
            --bar: #1f2937;
            --good: #10b981;
            --warn: #f59e0b;
            --bad: #ef4444;
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            overflow: hidden
        }

        #canvas {
            position: fixed;
            inset: 0;
            z-index: 0
        }

        #hud {
            position: fixed;
            inset: 16px auto auto 16px;
            z-index: 10;
            display: flex;
            gap: 12px;
            align-items: center;
            background: var(--panel);
            backdrop-filter: blur(6px);
            border: 1px solid #223;
            box-shadow: 0 8px 20px #0005;
            border-radius: 12px;
            padding: 10px 12px
        }

        #hud label {
            display: flex;
            align-items: center;
            gap: 8px
        }

        #hud input[type="range"] {
            width: 130px
        }

        #legend {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: 8px;
            color: var(--muted)
        }

        .swatch {
            width: 10px;
            height: 10px;
            border-radius: 999px;
            display: inline-block
        }

        .caption {
            font-size: 12px;
            color: var(--muted)
        }

        /* Bars: full-height scrollable panel */
        #bars {
            position: fixed;
            top: 72px;
            left: 16px;
            bottom: 16px;
            width: 430px;
            z-index: 10;
            background: var(--panel);
            border: 1px solid #223;
            border-radius: 12px;
            padding: 10px 12px;
            overflow-y: auto;
        }

        #bars h3 {
            margin: 2px 0 10px 0;
            font-weight: 600;
            font-size: 13px;
            color: #cbd5e1
        }

        /* Row layout: label | bar | metric (fixed) */
        .row {
            display: grid;
            grid-template-columns: 170px 1fr 110px;
            align-items: center;
            gap: 10px;
            margin: 10px 0
        }

        .lbl {
            color: #cbd5e1;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .meter {
            height: 12px;
            background: var(--bar);
            border-radius: 6px;
            overflow: hidden
        }

        .fill {
            height: 100%
        }

        .metric {
            font-variant-numeric: tabular-nums;
            color: #9aa8bd;
            text-align: right;
            white-space: nowrap
        }

        #bars::-webkit-scrollbar {
            width: 8px
        }

        #bars::-webkit-scrollbar-thumb {
            background: #2a3345;
            border-radius: 8px
        }
    </style>
</head>

<body>
    <canvas id="canvas"></canvas>

    <div id="hud" aria-label="controls">
        <label>Speed <input id="speed" type="range" min="0.1" max="1.5" step="0.05" value="1.0"></label>
        <label>Load <input id="load" type="range" min="0.25" max="5" step="0.05" value="1"></label>
        <label>Volatility <input id="vol" type="range" min="0" max="1.5" step="0.05" value="0.6"></label>
        <label>Rings <input id="rings" type="range" min="1" max="4" step="1" value="3"></label>
        <label><input id="trails" type="checkbox" checked> Trails</label>
        <div id="legend" title="Latency color bands">
            <span class="swatch" style="background:var(--good)"></span><span class="caption">≤200 ms</span>
            <span class="swatch" style="background:var(--warn)"></span><span class="caption">200–500 ms</span>
            <span class="swatch" style="background:var(--bad)"></span><span class="caption">&gt;500 ms</span>
        </div>
    </div>

    <div id="bars" aria-live="polite">
        <h3>Endpoints (requests/sec)</h3>
        <div id="barlist"></div>
        <div class="caption" style="margin-top:8px">Bar length = relative RPS • Color = average latency</div>
    </div>

    <script>
        // ---------- ROUTES (≈30; most fast, a few slow/batchy) ----------
        const endpoints = [
            { path: "/auth/login", baseRps: 45, avgLatency: 100 },
            { path: "/auth/refresh", baseRps: 35, avgLatency: 120 },
            { path: "/auth/logout", baseRps: 18, avgLatency: 90 },
            { path: "/users/me", baseRps: 70, avgLatency: 140 },
            { path: "/users/profile", baseRps: 40, avgLatency: 130 },
            { path: "/users/preferences", baseRps: 28, avgLatency: 110 },

            { path: "/feed", baseRps: 320, avgLatency: 160 },
            { path: "/feed/recommended", baseRps: 180, avgLatency: 150 },
            { path: "/search", baseRps: 115, avgLatency: 170 },
            { path: "/search/suggestions", baseRps: 210, avgLatency: 80 },

            { path: "/messages/send", baseRps: 50, avgLatency: 110 },
            { path: "/messages/thread", baseRps: 62, avgLatency: 120 },
            { path: "/notifications/list", baseRps: 140, avgLatency: 95 },

            { path: "/media/upload", baseRps: 22, avgLatency: 1200 }, // slow
            { path: "/media/thumbnail", baseRps: 70, avgLatency: 180 },
            { path: "/media/stream", baseRps: 38, avgLatency: 220 },
            { path: "/media/transcode", baseRps: 6, avgLatency: 2000 }, // very slow

            { path: "/store/checkout", baseRps: 26, avgLatency: 220 },
            { path: "/store/cart", baseRps: 95, avgLatency: 120 },
            { path: "/store/catalog", baseRps: 150, avgLatency: 140 },
            { path: "/payments/intent", baseRps: 34, avgLatency: 160 },
            { path: "/payments/refund", baseRps: 8, avgLatency: 900 }, // slow
            { path: "/orders/history", baseRps: 44, avgLatency: 200 },

            { path: "/admin/reindex", baseRps: 2, avgLatency: 2500 }, // batch
            { path: "/admin/backup", baseRps: 1, avgLatency: 2200 }, // batch
            { path: "/reports/export", baseRps: 3, avgLatency: 1800 }, // slow
            { path: "/analytics/summary", baseRps: 22, avgLatency: 300 },
            { path: "/analytics/realtime", baseRps: 60, avgLatency: 140 },

            { path: "/geo/lookup", baseRps: 55, avgLatency: 70 },
            { path: "/health", baseRps: 85, avgLatency: 60 },
            { path: "/feature-flags", baseRps: 120, avgLatency: 80 },
        ];

        // ---------- UTIL ----------
        function getVar(name) { return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
        function latencyColor(ms) { if (ms <= 200) return getVar('--good'); if (ms <= 500) return getVar('--warn'); return getVar('--bad'); }

        // Erlang(k, θ) noise: sum of k i.i.d. exponential(θ) samples. k integer ≥1.
        // Mean = k*θ; Var = k*θ². We’ll use small k (2 or 3) to model network/service stages.
        function erlang(k, theta) {
            let sum = 0;
            for (let i = 0; i < k; i++) {
                // Exponential with scale theta via inverse CDF
                const u = Math.random();
                sum += -theta * Math.log(1 - u);
            }
            return sum;
        }

        // ---------- STATE ----------
        const nodes = endpoints.map(ep => ({
            ...ep,
            angle: Math.random() * Math.PI * 2,
            curRps: ep.baseRps,
            curLatency: ep.avgLatency,
            emaRps: ep.baseRps,
            emaLat: ep.avgLatency,
            ringIdx: 0,                 // which ring (0 inner … n-1 outer)
            orbitRadiusFactor: 1.0,     // eased radius factor toward ring target
            targetRadiusFactor: 1.0,
            x: 0, y: 0, size: 10,
        }));

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        function resize() { canvas.width = innerWidth; canvas.height = innerHeight; }
        addEventListener('resize', resize, { passive: true }); resize();

        const speedEl = document.getElementById('speed');
        const loadEl = document.getElementById('load');
        const volEl = document.getElementById('vol');
        const trailsEl = document.getElementById('trails');
        const ringsEl = document.getElementById('rings');
        const barList = document.getElementById('barlist');

        // ---------- RING BANDING (dynamic by quantiles) ----------
        let ringThresholds = []; // updated once per second
        function computeRingThresholds() {
            const k = Math.max(1, Math.min(4, +ringsEl.value | 0));
            if (k === 1) { ringThresholds = [Infinity]; return; }
            const vals = nodes.map(n => n.emaLat).slice().sort((a, b) => a - b);
            ringThresholds = [];
            for (let i = 1; i < k; i++) {
                const qIdx = Math.floor((i / k) * (vals.length - 1));
                ringThresholds.push(vals[qIdx]);
            }
            ringThresholds.push(Infinity);
        }

        // Map latency → ring index (0..k-1). Inner ring = fastest.
        function ringIndexForLatency(ms) {
            for (let i = 0; i < ringThresholds.length; i++) {
                if (ms <= ringThresholds[i]) return i;
            }
            return ringThresholds.length - 1;
        }

        // Given ring count, produce radius factors (inner..outer)
        function ringRadiusFactors(k) {
            // Keep a nice band between 0.78R .. 1.00R
            const inner = 0.78, outer = 1.00;
            if (k === 1) return [0.90];
            const step = (outer - inner) / (k - 1);
            return Array.from({ length: k }, (_, i) => inner + i * step);
        }

        // ---------- SIM ----------
        function simulate(dt) {
            const load = +loadEl.value;
            const vol = +volEl.value;
            const speed = +speedEl.value;

            // Erlang parameters: small shape, scale grows with volatility
            const kStage = 2;                // 2-stage typical path
            const thetaBase = 12;            // base ms per stage
            const thetaVol = thetaBase * (0.5 + vol); // more volatility ⇒ fatter tail

            for (const n of nodes) {
                // RPS with lognormal-ish multiplicative noise
                const targetRps = Math.max(0.1, n.baseRps * load);
                const burst = Math.exp((Math.random() * 2 - 1) * 0.35 * vol);
                const noisyRps = targetRps * burst;
                n.curRps = n.curRps * 0.86 + noisyRps * 0.14;
                n.emaRps = n.emaRps * 0.90 + n.curRps * 0.10;

                // Latency baseline + pressure + Erlang burst noise
                const pressure = Math.max(0, n.curRps / n.baseRps - 1); // >0 when overloaded
                const burstMs = erlang(kStage, thetaVol);              // ms
                const targetLat = Math.max(15, n.avgLatency + pressure * 60 + (burstMs - kStage * thetaVol) * 0.9);
                n.curLatency = n.curLatency * 0.92 + targetLat * 0.08;
                n.emaLat = n.emaLat * 0.90 + n.curLatency * 0.10;

                // Angular speed: with speed=1, 100ms → 10 rev/s
                const oneRevSeconds = Math.max(0.02, (n.avgLatency / 1000) / speed);
                const radPerSec = (2 * Math.PI) / oneRevSeconds;
                n.angle = (n.angle + radPerSec * dt) % (Math.PI * 2);
            }

            // Update ring placement + smooth radius toward target
            const k = Math.max(1, Math.min(4, +ringsEl.value | 0));
            const radii = ringRadiusFactors(k);
            for (const n of nodes) {
                const idx = ringIndexForLatency(n.emaLat);
                n.ringIdx = idx;
                n.targetRadiusFactor = radii[idx];
                // ease toward ring radius (prevents popping)
                n.orbitRadiusFactor = n.orbitRadiusFactor * 0.90 + n.targetRadiusFactor * 0.10;
            }
        }

        // ---------- RENDER ----------
        const TRAIL_ALPHA = 0.12;
        function render() {
            const w = canvas.width, h = canvas.height;

            if (!trailsEl.checked) ctx.clearRect(0, 0, w, h);
            else { ctx.fillStyle = `rgba(11,18,32,${TRAIL_ALPHA})`; ctx.fillRect(0, 0, w, h); }

            const cx = w * 0.64, cy = h * 0.56;
            const baseR = Math.min(w, h) * 0.36;

            // Draw rings
            const k = Math.max(1, Math.min(4, +ringsEl.value | 0));
            const rf = ringRadiusFactors(k);
            ctx.lineWidth = 4; ctx.strokeStyle = getVar('--ring');
            rf.forEach(f => { ctx.beginPath(); ctx.arc(cx, cy, baseR * f, 0, Math.PI * 2); ctx.stroke(); });

            const peakRps = Math.max(...nodes.map(n => n.emaRps));
            const rpsToSize = rps => 6 + 16 * (peakRps ? rps / peakRps : 0);

            const primary = nodes.reduce((a, b) => a.emaRps > b.emaRps ? a : b, nodes[0]);

            for (const n of nodes) {
                const r = baseR * n.orbitRadiusFactor;
                const x = cx + Math.cos(n.angle) * r;
                const y = cy + Math.sin(n.angle) * r;
                n.x = x; n.y = y;
                n.size = rpsToSize(n.emaRps);

                // Halo (subtle)
                const lag = Math.min(1.4, n.emaLat / 600);
                ctx.beginPath();
                ctx.arc(x, y, n.size * 1.45 * lag, 0, Math.PI * 2);
                ctx.fillStyle = latencyColor(n.emaLat) + '1A';
                ctx.fill();

                // Node
                ctx.beginPath();
                ctx.arc(x, y, n.size, 0, Math.PI * 2);
                ctx.fillStyle = latencyColor(n.emaLat);
                ctx.shadowColor = '#0006'; ctx.shadowBlur = 4;
                ctx.fill(); ctx.shadowBlur = 0;

                // Crisp rim
                ctx.lineWidth = 1.25;
                ctx.strokeStyle = '#0b1220';
                ctx.stroke();

                // Primary outline for definition
                if (n === primary) {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#c9e2ffAA';
                    ctx.beginPath();
                    ctx.arc(x, y, n.size + 2.5, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Motion tick
                ctx.strokeStyle = '#ffffff22'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(x, y);
                ctx.lineTo(cx + Math.cos(n.angle) * (r + 14), cy + Math.sin(n.angle) * (r + 14));
                ctx.stroke();
            }

            renderBars(peakRps);
        }

        // ---------- BARS (stable order) ----------
        function renderBars(peak) {
            barList.innerHTML = '';
            for (const n of nodes) {
                const row = document.createElement('div'); row.className = 'row';

                const lbl = document.createElement('div'); lbl.className = 'lbl'; lbl.textContent = n.path;

                const meter = document.createElement('div'); meter.className = 'meter';
                const fill = document.createElement('div'); fill.className = 'fill';
                const norm = peak ? n.emaRps / peak : 0;
                fill.style.width = Math.max(2, Math.round(norm * 100)) + '%';
                fill.style.background = latencyColor(n.emaLat);
                meter.appendChild(fill);

                const m = document.createElement('div'); m.className = 'metric';
                m.textContent = `${n.emaRps.toFixed(0)} rps • ${n.emaLat.toFixed(0)} ms`;

                row.appendChild(lbl); row.appendChild(meter); row.appendChild(m);
                barList.appendChild(row);
            }
        }

        // ---------- LOOP + PERIODIC RING THRESHOLDS ----------
        let last = performance.now(), lastBandUpdate = performance.now();
        function tick(now) {
            let dt = (now - last) / 1000;
            const slept = dt > 0.2;
            dt = Math.min(0.05, Math.max(0.001, dt));
            last = now;

            if (slept && trailsEl.checked) ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Recompute band thresholds about once per second (prevents jitter)
            if (now - lastBandUpdate > 1000) {
                computeRingThresholds();
                lastBandUpdate = now;
            }

            simulate(dt);
            render();
            requestAnimationFrame(tick);
        }
        computeRingThresholds();
        requestAnimationFrame(tick);
    </script>
</body>

</html>